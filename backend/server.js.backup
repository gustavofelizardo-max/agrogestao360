const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { Pool } = require('pg');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3001;

// Configuração do PostgreSQL
const pool = new Pool({
  connectionString: process.env.DATABASE_URL || 'postgresql://gustavo.felizardo:@localhost:5432/agrotech',
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

// Middleware
app.use(cors({
  origin: ['http://localhost:3000', 'http://localhost:3001'],
  credentials: true
}));
app.use(express.json({ limit: '10mb' }));

// Middleware de autenticação
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ success: false, message: 'Token de acesso requerido' });
  }

  jwt.verify(token, process.env.JWT_SECRET || 'agrotech-jwt-secret-2024', (err, user) => {
    if (err) {
      return res.status(403).json({ success: false, message: 'Token inválido' });
    }
    req.user = user;
    next();
  });
};

// ============== ROTAS DE TESTE ==============

app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'AgroTech Backend funcionando!',
    timestamp: new Date().toISOString(),
    database: 'PostgreSQL conectado'
  });
});

// ============== ROTAS DE AUTENTICAÇÃO ==============

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password, userType } = req.body;

    console.log('🔐 Tentativa de login:', { email, userType });

    if (!email || !password || !userType) {
      return res.status(400).json({
        success: false,
        message: 'Email, senha e tipo de usuário são obrigatórios'
      });
    }

    const userQuery = 'SELECT * FROM users WHERE email = $1 AND user_type = $2 AND active = true';
    const userResult = await pool.query(userQuery, [email, userType]);

    if (userResult.rows.length === 0) {
      console.log('❌ Usuário não encontrado');
      return res.status(401).json({
        success: false,
        message: 'Credenciais inválidas'
      });
    }

    const user = userResult.rows[0];
    const isPasswordValid = await bcrypt.compare(password, user.password);

    if (!isPasswordValid) {
      console.log('❌ Senha inválida');
      return res.status(401).json({
        success: false,
        message: 'Credenciais inválidas'
      });
    }

    const token = jwt.sign(
      { 
        userId: user.id, 
        email: user.email, 
        userType: user.user_type 
      },
      process.env.JWT_SECRET || 'agrotech-jwt-secret-2024',
      { expiresIn: '24h' }
    );

    console.log('✅ Login realizado com sucesso');

    res.json({
      success: true,
      message: 'Login realizado com sucesso',
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        userType: user.user_type,
        profileImage: user.profile_image
      }
    });

  } catch (error) {
    console.error('💥 Erro no login:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// ============== ROTAS DE CULTURAS ==============

app.get('/api/cultures', authenticateToken, async (req, res) => {
  try {
    const query = 'SELECT * FROM cultures WHERE active = true ORDER BY name';
    const result = await pool.query(query);
    
    res.json({
      success: true,
      cultures: result.rows
    });
  } catch (error) {
    console.error('Erro ao buscar culturas:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

app.post('/api/cultures', authenticateToken, async (req, res) => {
  try {
    const { name, category, season, cycle_days, description } = req.body;

    if (!name) {
      return res.status(400).json({
        success: false,
        message: 'Nome da cultura é obrigatório'
      });
    }

    const query = `
      INSERT INTO cultures (name, category, season, cycle_days, description)
      VALUES ($1, $2, $3, $4, $5)
      RETURNING *
    `;

    const values = [name, category, season, cycle_days, description];
    const result = await pool.query(query, values);
    
    res.json({
      success: true,
      message: 'Cultura cadastrada com sucesso',
      culture: result.rows[0]
    });
  } catch (error) {
    if (error.code === '23505') { // Unique violation
      return res.status(400).json({
        success: false,
        message: 'Cultura já existe'
      });
    }
    console.error('Erro ao cadastrar cultura:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// ============== ROTAS DE PROPRIEDADES ==============

app.get('/api/properties', authenticateToken, async (req, res) => {
  try {
    const query = 'SELECT * FROM properties WHERE user_id = $1 ORDER BY created_at DESC';
    const result = await pool.query(query, [req.user.userId]);
    
    console.log(`✅ Buscando propriedades para usuário ${req.user.userId}:`, result.rows.length);
    
    res.json({
      success: true,
      properties: result.rows
    });
  } catch (error) {
    console.error('Erro ao buscar propriedades:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

app.post('/api/properties', authenticateToken, async (req, res) => {
  try {
    console.log('📝 Dados recebidos para cadastro:', req.body);
    console.log('👤 Usuário:', req.user);

    const {
      name, owner, document, phone, email, cep, address, number,
      complement, neighborhood, city, state, country, latitude, longitude,
      area, arable_area, reserve_area, crops, employees, has_irrigation,
      has_machinery, has_storage, description
    } = req.body;

    // Validações obrigatórias
    if (!name || !owner) {
      return res.status(400).json({
        success: false,
        message: 'Nome da propriedade e proprietário são obrigatórios'
      });
    }

    const query = `
      INSERT INTO properties (
        user_id, name, owner, document, phone, email, cep, address, number,
        complement, neighborhood, city, state, country, latitude, longitude,
        area, arable_area, reserve_area, crops, employees, has_irrigation,
        has_machinery, has_storage, description
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25)
      RETURNING *
    `;

    const values = [
      req.user.userId, name, owner, document || null, phone || null, email || null, 
      cep || null, address || null, number || null, complement || null, 
      neighborhood || null, city || null, state || null, country || 'Brasil', 
      latitude || null, longitude || null, area || null, arable_area || null, 
      reserve_area || null, crops || null, employees || 0, has_irrigation || false,
      has_machinery || false, has_storage || false, description || null
    ];

    console.log('💾 Executando query de inserção...');
    const result = await pool.query(query, values);
    
    console.log('✅ Propriedade inserida com sucesso:', result.rows[0]);
    
    res.json({
      success: true,
      message: 'Propriedade cadastrada com sucesso',
      property: result.rows[0]
    });
  } catch (error) {
    console.error('💥 Erro ao cadastrar propriedade:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor',
      error: error.message 
    });
  }
});

app.put('/api/properties/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const {
      name, owner, document, phone, email, cep, address, number,
      complement, neighborhood, city, state, country, latitude, longitude,
      area, arable_area, reserve_area, crops, employees, has_irrigation,
      has_machinery, has_storage, description
    } = req.body;

    const query = `
      UPDATE properties SET
        name = $2, owner = $3, document = $4, phone = $5, email = $6, cep = $7,
        address = $8, number = $9, complement = $10, neighborhood = $11, city = $12,
        state = $13, country = $14, latitude = $15, longitude = $16, area = $17,
        arable_area = $18, reserve_area = $19, crops = $20, employees = $21,
        has_irrigation = $22, has_machinery = $23, has_storage = $24, description = $25,
        updated_at = CURRENT_TIMESTAMP
      WHERE id = $1 AND user_id = $26
      RETURNING *
    `;

    const values = [
      id, name, owner, document || null, phone || null, email || null, cep || null, 
      address || null, number || null, complement || null, neighborhood || null, 
      city || null, state || null, country || 'Brasil', latitude || null, 
      longitude || null, area || null, arable_area || null, reserve_area || null, 
      crops || null, employees || 0, has_irrigation || false, has_machinery || false, 
      has_storage || false, description || null, req.user.userId
    ];

    const result = await pool.query(query, values);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Propriedade não encontrada' });
    }
    
    console.log('✅ Propriedade atualizada:', result.rows[0]);
    
    res.json({
      success: true,
      message: 'Propriedade atualizada com sucesso',
      property: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao atualizar propriedade:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

app.delete('/api/properties/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    const query = 'DELETE FROM properties WHERE id = $1 AND user_id = $2 RETURNING *';
    const result = await pool.query(query, [id, req.user.userId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Propriedade não encontrada' });
    }
    
    console.log('✅ Propriedade excluída:', result.rows[0].name);
    
    res.json({
      success: true,
      message: 'Propriedade excluída com sucesso'
    });
  } catch (error) {
    console.error('Erro ao excluir propriedade:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// ============== ROTAS DE CONFIGURAÇÕES DE API ==============

app.get('/api/configs', authenticateToken, async (req, res) => {
  try {
    const query = 'SELECT * FROM api_configs WHERE user_id = $1 ORDER BY api_name';
    const result = await pool.query(query, [req.user.userId]);
    
    res.json({
      success: true,
      configs: result.rows
    });
  } catch (error) {
    console.error('Erro ao buscar configurações:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

app.post('/api/configs', authenticateToken, async (req, res) => {
  try {
    const { api_name, api_key, api_url, config_data } = req.body;

    const query = `
      INSERT INTO api_configs (user_id, api_name, api_key, api_url, config_data)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (user_id, api_name) 
      DO UPDATE SET api_key = $3, api_url = $4, config_data = $5, updated_at = CURRENT_TIMESTAMP
      RETURNING *
    `;

    const values = [req.user.userId, api_name, api_key, api_url, config_data];
    const result = await pool.query(query, values);
    
    res.json({
      success: true,
      message: 'Configuração salva com sucesso',
      config: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao salvar configuração:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// ============== ROTAS DE CLIMA ==============

app.get('/api/weather/:cep', authenticateToken, async (req, res) => {
  try {
    const { cep } = req.params;
    
    // Buscar coordenadas pelo CEP
    const viaCepResponse = await fetch(`https://viacep.com.br/ws/${cep}/json/`);
    const viaCepData = await viaCepResponse.json();
    
    if (viaCepData.erro) {
      return res.status(400).json({ success: false, message: 'CEP inválido' });
    }

    // Buscar dados meteorológicos
    const weatherResponse = await fetch(
      `https://api.openweathermap.org/data/2.5/weather?q=${viaCepData.localidade},BR&appid=${process.env.OPENWEATHER_API_KEY || 'demo_key'}&units=metric&lang=pt_br`
    );
    
    if (!weatherResponse.ok) {
      // Dados mockados para demonstração
      const mockWeather = {
        location: `${viaCepData.localidade} - ${viaCepData.uf}`,
        temperature: 25,
        feelsLike: 27,
        humidity: 65,
        pressure: 1013,
        description: 'ensolarado',
        icon: '01d',
        windSpeed: 5.2,
        visibility: 10,
        sunrise: '06:30',
        sunset: '18:45'
      };
      
      return res.json({
        success: true,
        weather: mockWeather,
        message: 'Dados meteorológicos simulados (configure API key)'
      });
    }
    
    const weatherData = await weatherResponse.json();
    
    res.json({
      success: true,
      weather: {
        location: `${viaCepData.localidade} - ${viaCepData.uf}`,
        temperature: weatherData.main.temp,
        feelsLike: weatherData.main.feels_like,
        humidity: weatherData.main.humidity,
        pressure: weatherData.main.pressure,
        description: weatherData.weather[0].description,
        icon: weatherData.weather[0].icon,
        windSpeed: weatherData.wind.speed,
        visibility: weatherData.visibility / 1000,
        sunrise: new Date(weatherData.sys.sunrise * 1000).toLocaleTimeString(),
        sunset: new Date(weatherData.sys.sunset * 1000).toLocaleTimeString()
      }
    });
  } catch (error) {
    console.error('Erro ao buscar dados meteorológicos:', error);
    res.status(500).json({ success: false, message: 'Erro ao buscar dados meteorológicos' });
  }
});

// ============== ROTAS DE MERCADO ==============

app.get('/api/market/:cep', authenticateToken, async (req, res) => {
  try {
    const { cep } = req.params;
    
    // Dados simulados de mercado baseados no CEP
    const mockMarketData = {
      region: `Região do CEP ${cep}`,
      commodities: [
        { name: 'Soja', price: 145.50, unit: 'saca 60kg', variation: '+2.5%' },
        { name: 'Milho', price: 89.30, unit: 'saca 60kg', variation: '-1.2%' },
        { name: 'Algodão', price: 2.85, unit: 'kg', variation: '+0.8%' },
        { name: 'Café', price: 8.25, unit: 'saca 60kg', variation: '+3.1%' }
      ],
      lastUpdate: new Date().toISOString()
    };
    
    res.json({
      success: true,
      market: mockMarketData,
      message: 'Dados de mercado simulados (configure API real)'
    });
  } catch (error) {
    console.error('Erro ao buscar dados de mercado:', error);
    res.status(500).json({ success: false, message: 'Erro ao buscar dados de mercado' });
  }
});

// ============== ROTAS DE DASHBOARD ==============

app.get('/api/dashboard', authenticateToken, async (req, res) => {
  try {
    const { userType } = req.user;
    
    // Buscar propriedades do usuário
    const propertiesQuery = 'SELECT * FROM properties WHERE user_id = $1';
    const propertiesResult = await pool.query(propertiesQuery, [req.user.userId]);
    const properties = propertiesResult.rows;
    
    console.log(`📊 Dashboard para ${userType}, ${properties.length} propriedades`);
    
    let dashboardData = {};
    
    if (userType === 'producer') {
      const totalArea = properties.reduce((sum, p) => sum + (parseFloat(p.area) || 0), 0);
      const totalArableArea = properties.reduce((sum, p) => sum + (parseFloat(p.arable_area) || 0), 0);
      
      dashboardData = {
        totalFazendas: properties.length,
        areaCultivada: totalArea,
        areaAravel: totalArableArea,
        alertasAtivos: 2,
        propriedades: properties.map(p => ({
          id: p.id,
          name: p.name,
          area: p.area,
          city: p.city,
          state: p.state,
          crops: p.crops
        }))
      };
    } else if (userType === 'supplier') {
      dashboardData = {
        totalPedidos: 15,
        pedidosPendentes: 3,
        vendasMes: 45000,
        clientesAtivos: 12
      };
    } else if (userType === 'buyer') {
      dashboardData = {
        totalCompras: 8,
        comprasPendentes: 2,
        gastoMes: 32000,
        fornecedoresAtivos: 6
      };
    }
    
    res.json(dashboardData);
  } catch (error) {
    console.error('Erro ao buscar dados do dashboard:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// ============== INICIALIZAÇÃO ==============

// Criar usuários padrão se não existirem
const createDefaultUsers = async () => {
  try {
    const defaultUsers = [
      {
        name: 'João Produtor',
        email: 'produtor@teste.com',
        password: '123456',
        user_type: 'producer'
      },
      {
        name: 'Maria Fornecedora',
        email: 'fornecedor@teste.com',
        password: '123456',
        user_type: 'supplier'
      },
      {
        name: 'Carlos Comprador',
        email: 'comprador@teste.com',
        password: '123456',
        user_type: 'buyer'
      },
      {
        name: 'Gustavo Felizardo',
        email: 'gufeliza@gmail.com',
        password: '123456',
        user_type: 'producer'
      }
    ];

    for (const user of defaultUsers) {
      const checkQuery = 'SELECT id FROM users WHERE email = $1';
      const checkResult = await pool.query(checkQuery, [user.email]);
      
      if (checkResult.rows.length === 0) {
        const hashedPassword = await bcrypt.hash(user.password, 10);
        const insertQuery = 'INSERT INTO users (name, email, password, user_type) VALUES ($1, $2, $3, $4)';
        await pool.query(insertQuery, [user.name, user.email, hashedPassword, user.user_type]);
        console.log(`✅ Usuário criado: ${user.email}`);
      }
    }
  } catch (error) {
    console.error('Erro ao criar usuários padrão:', error);
  }
};

// Iniciar servidor
app.listen(PORT, async () => {
  console.log(`🚀 Servidor AgroTech rodando na porta ${PORT}`);
  console.log(`📍 Health: http://localhost:${PORT}/api/health`);
  console.log(`🔐 Login: http://localhost:${PORT}/api/auth/login`);
  
  // Testar conexão com banco
  try {
    const result = await pool.query('SELECT NOW()');
    console.log('✅ PostgreSQL conectado:', result.rows[0].now);
  } catch (error) {
    console.error('❌ Erro ao conectar PostgreSQL:', error.message);
  }
  
  // Criar usuários padrão
  await createDefaultUsers();
  
  console.log('🎯 Sistema AgroTech Completo inicializado!');
});
